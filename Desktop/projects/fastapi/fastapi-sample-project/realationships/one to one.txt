from sqlalchemy import ForeignKey, Integer
from sqlalchemy.orm import relationship

# One-to-One: Item -> ItemDetail
class ItemDetailModel(Base):
    __tablename__ = "item_details"
    
    id = Column(String, primary_key=True, index=True)
    item_id = Column(String, ForeignKey("items.id"), unique=True, nullable=False)
    specifications = Column(Text, nullable=True)
    weight = Column(Float, nullable=True)
    dimensions = Column(String(100), nullable=True)
    manufacturer = Column(String(100), nullable=True)
    created_at = Column(DateTime)
    updated_at = Column(DateTime)

# Update ItemModel to include relationship
class ItemModel(Base):
    __tablename__ = "items"
    
    id = Column(String, primary_key=True, index=True)
    name = Column(String(255), index=True)
    description = Column(Text, nullable=True)
    price = Column(Float)
    category = Column(String(100))
    created_at = Column(DateTime)
    updated_at = Column(DateTime)
    
    # One-to-One relationship
    detail = relationship("ItemDetailModel", back_populates="item", uselist=False)

# Update ItemDetailModel relationship
ItemDetailModel.item = relationship("ItemModel", back_populates="detail")

# Pydantic models for ItemDetail
class ItemDetailCreate(BaseModel):
    specifications: Optional[str] = None
    weight: Optional[float] = None
    dimensions: Optional[str] = None
    manufacturer: Optional[str] = None

class ItemDetailResponse(BaseModel):
    id: str
    item_id: str
    specifications: Optional[str] = None
    weight: Optional[float] = None
    dimensions: Optional[str] = None
    manufacturer: Optional[str] = None
    created_at: datetime
    updated_at: datetime
    
    model_config = {"from_attributes": True}

class ItemResponseWithDetail(ItemResponse):
    detail: Optional[ItemDetailResponse] = None

# API endpoints for one-to-one
@app.post("/items/{item_id}/detail", response_model=ItemDetailResponse)
async def create_item_detail(
    item_id: str, 
    detail: ItemDetailCreate, 
    db: Session = Depends(get_db)
):
    # Check if item exists
    item = db.query(ItemModel).filter(ItemModel.id == item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    # Check if detail already exists
    existing_detail = db.query(ItemDetailModel).filter(ItemDetailModel.item_id == item_id).first()
    if existing_detail:
        raise HTTPException(status_code=400, detail="Item detail already exists")
    
    detail_id = generate_id()
    current_time = datetime.now()
    
    db_detail = ItemDetailModel(
        id=detail_id,
        item_id=item_id,
        specifications=detail.specifications,
        weight=detail.weight,
        dimensions=detail.dimensions,
        manufacturer=detail.manufacturer,
        created_at=current_time,
        updated_at=current_time
    )
    
    db.add(db_detail)
    db.commit()
    db.refresh(db_detail)
    return db_detail

@app.get("/items/{item_id}/with-detail", response_model=ItemResponseWithDetail)
async def read_item_with_detail(item_id: str, db: Session = Depends(get_db)):
    item = db.query(ItemModel).filter(ItemModel.id == item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    return item